%{
int yylex();
int yyerror(char*);
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "SymbolTable.c"
#include "LinkedList.c"
#include "Record.c"
#include "PatchStruct.c"
extern int lineno;
record_global GlobalTrack = {0,1};
FILE *output;
%}

%token IS BEG END PROCEDURE ID NUMBER TYPE ARRAY RAISE OTHERS
%token RECORD IN OUT RANGE CONSTANT ASSIGN EXCEPTION NULLWORD LOOP IF
%token THEN ELSEIF ELSE EXIT WHEN AND OR EQ NEQ LT GT GTE LTE TICK
%token NOT EXP ARROW OF DOTDOT ENDIF ENDREC ENDLOOP EXITWHEN
%type <integer> NUMBER constant_number declarative_part begin loop_start main_specification
%type <var> ID type_name mode IN OUT EXCEPTION adding_operation multiplying_operation relational_operation boolean_operation procedure_specification procedure_body_prime
%type <head> identifier_list
%type <node_p> parameters   formal_parameter_part
%type <record_p> primary factor term simple_expression relation expression op_assign condition
%type <RW> expression_list op_param
%union {
    int integer;
    char * var;
    struct LL_node * head;
    struct node * node_p;
    struct record * record_p;
    struct LL_RW * RW;
}
%%

program                 : main_body {printf ("\n*******\nDONE.\n*******\n");}
                        ;
main_body               : main_specification IS
                          declarative_part begin
                          sequence_of_statements
                          exception_part END ';'
                        {
		          	         printf("\nPopping scope for %s, so print tree\n", arr[i].Key);
		          	         printDFS(arr[i].Root);
		          	         Pop();
				                 fprintf(output, "%d     r%d := contents b, 1\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				                 fprintf(output, "%d     b := contents b, 3\n", GlobalTrack.Instruction++);
				                 fprintf(output, "%d     pc := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num++);
                         AddPatchList(0, GlobalTrack.Instruction);
                         AddPatchList(1, GlobalTrack.Instruction + $3);
                         printPL(PatchListLL);
				                }
                        ;
main_specification      : PROCEDURE ID
	                {
	                 Push($2);
	                 fprintf(output, "%d     b := ?\n", GlobalTrack.Instruction++);
	                 fprintf(output, "%d     contents b, 0 := ?\n", GlobalTrack.Instruction++);
	                 fprintf(output, "%d     contents b, 1 := 4\n", GlobalTrack.Instruction++);
	                 struct patch_list * Temp;
	                 Temp = create_new_patch_list(GlobalTrack.Instruction);
	                 PatchListLL = Temp;
	                 //printf("PatchList Location is %d\n", PatchListLL -> location);
	                 //PatchListLL -> location = GlobalTrack.Instruction;
	                 //printf("PatchList Location is %d\n", PatchListLL -> location);
	                 fprintf(output, "%d     pc := ?\n", GlobalTrack.Instruction++);
	                 fprintf(output, "%d     halt\n", GlobalTrack.Instruction++);
 			 $$ = GlobalTrack.Instruction;
	                 incrementOffset(4);
	                }
                        ;
procedure_body          : procedure_body_prime IS
                          declarative_part begin
                          sequence_of_statements
                          exception_part END ';'
	          	{
			 node_t * outcome = Search($1);
         		 outcome -> Proc_Beg = $4;
	          	 printf("\nPopping scope for %s, so print tree\n", arr[i].Key);
	          	 printDFS(arr[i].Root);
	          	 Pop();
			 fprintf(output, "%d     r%d := contents b, 1\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
			 fprintf(output, "%d     b := contents b, 3\n", GlobalTrack.Instruction++);
			 fprintf(output, "%d     pc := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num++);
	          	}
	                ;
begin			: BEG
  			{
  			 PatchListLL -> insert = GlobalTrack.Instruction;
  			 //printf("PatchList Insert is %d\n", PatchListLL -> insert);
  			 $$ = GlobalTrack.Instruction;
  			}
  			;
procedure_body_prime	: procedure_specification formal_parameter_part {$$ = $1;}
                  	;
procedure_specification : PROCEDURE ID
	          	{
	          	 struct node * node_p;
	          	 node_p = create_new_node($2);
	          	 strcpy(node_p->var, $2);
	          	 Add(node_p->var);
	             	 node_t * outcome = RecursiveSearch(arr[i].Root, node_p->var);
	          	 strcpy(outcome->kind, "procedure");
	          	 $$ = $2;
	          	 Push(node_p->var);
			 nextOffset();//Go to the Next Offset
			 incrementOffset(4);
			 outcome->Size_of = current_pos;
	          	}
                        ;
formal_parameter_part   : '(' parameters ')'
                  		{$$ = $2;}
                        | %empty
                  		{$$ = NULL;}
                        ;
parameters              : parameters ';' identifier_list ':' mode type_name
		          	{
		                 LL_node current = $3;
		          	 print(current);
		                 node_t * outcome = RecursiveSearch(arr[i].Root, $1->var); //Parameter search.
		          	 while (current != NULL) {
		          		if (RecursiveSearch(arr[i].Root, current->data) != NULL) {
		          			printf("     ERROR: Duplicate IDs!\n");
		          			current = current->next;
		          			continue;
		          		}
		              		Add(current->data);
		             		node_t * outcome1 = RecursiveSearch(arr[i].Root, current->data); //ID LL search.
		          		strcpy(outcome1->mode, $5);
		          		outcome1->parent_type = Search($6);
		          		strcpy(outcome1->kind, "variable");
		          		outcome->next = outcome1;
		                	current = current->next;
		          		printf(" %s\n", outcome1->mode);
		                  	$$ = outcome;
		              	 };
				}
                        | identifier_list ':' mode type_name
				{
				 LL_node current = $1;
				 print(current);
				 while (current != NULL) {
					if (RecursiveSearch(arr[i].Root, current->data) != NULL) {
						printf("     ERROR: Duplicate IDs!\n");
						current = current->next;
						continue;
					}
				 	Add(current->data);
					node_t * outcome = RecursiveSearch(arr[i].Root, current->data);
					strcpy(outcome->mode, $3);
					outcome->parent_type = Search($4);
					strcpy(outcome->kind, "variable");
					current = current->next;
					printf(" %s\n", outcome->mode);
					$$ = outcome;
				 };
				}
                        ;
mode                    : IN OUT
				{$$ = "in out";}
                        | OUT
				{$$ = "out";}
                        | IN
				{$$ = "in";}
                        | %empty
				{$$ = "in";}
                        ;
identifier_list         : ID ',' identifier_list
				{
				 $3 = insertList($3, $1);
				 $$ = $3;
				}
                        | ID
				{
				 struct LL_node *head;
				 head = init($1);
				 $$ = head;
				}
                        ;
type_name               : ID
				{$$ = $1;}
                        ;
declarative_part        : objects ';' declarative_part {$$ = currentOffset();}
                        | types ';' declarative_part {$$ = currentOffset();}
                        | exceptions ';' declarative_part {$$ = currentOffset();}
                        | declarative_part_prime {$$ = currentOffset();}
                        ;
declarative_part_prime  : procedure_body declarative_part_prime
                        | %empty
                        ;
types                   : TYPE ID IS ARRAY  '(' constant_number DOTDOT constant_number ')' OF type_name
		          	{
		          	Add($2);
		          	node_t * outcome = RecursiveSearch(arr[i].Root, $2);
		          	node_t * temp = RecursiveSearch(arr[0].Root, $11);
		          	outcome->lower = $6;
		          	outcome->upper = $8;
                outcome->offset = ($8 - $6 + 1) * temp -> offset;
		           	outcome->component_type = Search($11);
		          	strcpy(outcome->kind, "array");
				}
                  	;
types                   : TYPE ID IS RECORD component_list ENDREC
			;
types                   : TYPE ID IS RANGE constant_number DOTDOT constant_number
		                {
		                 if (RecursiveSearch(arr[i].Root, $2) != NULL) {
					printf("     ERROR: Duplicate IDs!\n");
		                 } else {
					Add($2);
					node_t* outcome = Search($2);
					strcpy(outcome->kind, "range");
		               		outcome->upper = $7;
		                    	outcome->lower = $5;
		                 }
		                }
                        ;
component_list          : component ';' component_list
                        | component ';'
                        ;
component               : objects
                        ;
objects                 : identifier_list ':' type_name
		          	{
		          	 printf("     line#: %d - ", lineno);
		                 LL_node current = $1;
		          	 print(current);
		          	 printf(" %s\n", $3);
		          	 node_t * temp = Search($3);
		                 while (current != NULL) {
		          		if (RecursiveSearch(arr[i].Root, current->data) != NULL) {
		          			printf("     ERROR: Duplicate IDs!\n");
		          			current = current->next;
		          			continue;
		          		}
		                	Add(current->data);
		                  	node_t * outcome = RecursiveSearch(arr[i].Root, current->data);
		          		strcpy(outcome->kind, "variable");
		          		outcome->parent_type = temp;
					        outcome->offset = currentOffset();
					        outcome->lower = temp->lower;
					        outcome->upper = temp->upper;
					        incrementOffset(outcome->parent_type->offset);
		          		current = current->next;
		              	 }
		          	}
                        | identifier_list ':' CONSTANT ASSIGN constant_expression
                        ;
constant_number		: ID
				{$$ = 0;}
			| NUMBER
				{$$ = $1;}
			;
constant_expression     : expression
                        ;
exceptions              : identifier_list ':' EXCEPTION
				{
				 LL_node current;
		                 current = $1;
		                 while (current != NULL) {
		                 	if (RecursiveSearch(arr[i].Root, current->data) != NULL) {
		                        printf("     ERROR: Duplicate IDs!\n");
		                        current = current->next;
		                        continue;
		                	}
		                	Add(current->data);
		               		node_t * outcome = RecursiveSearch(arr[i].Root, current->data);
	     				strcpy(outcome->kind, "exception");
	     				current = current -> next;
		 		 }
		                }
                        ;
sequence_of_statements  : statement sequence_of_statements
                        | %empty
                        ;
statement               : NULLWORD ';'
			| ID op_param op_assign ';'
			{
			 node_t * outcome = Search($1); //Search for $1 in Global Tree
			 int x = SearchPosition($1); //Check if it is local
			 if ($3 -> Value == 0 && $2 == NULL) { //If op_param and op_assign are both empty, it is a procedure call.
				fprintf(output, "%d     r%d := b\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				fprintf(output, "%d     b := contents r%d, 0\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				fprintf(output, "%d     contents b, 3 := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				if (x == 0) {
					fprintf(output, "%d     contents b, 2 := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				} else {
					while (x > 0) {
				 		fprintf(output, "%d     r%d := contents r%d, 2\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
						x--;
					}
					fprintf(output, "%d     contents b, 2 := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				}
				GlobalTrack.register_Num++;
				fprintf(output, "%d     r%d := %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, OffsetArr[outcome->Size_of]);
				fprintf(output, "%d     contents b, 0 := b + r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				GlobalTrack.register_Num++;
				fprintf(output, "%d     r%d := %d\n", GlobalTrack.Instruction, GlobalTrack.register_Num, GlobalTrack.Instruction + 3);
				GlobalTrack.Instruction++;
				fprintf(output, "%d     contents b, 1 := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
				GlobalTrack.register_Num++;
				fprintf(output, "%d     pc := %d\n", GlobalTrack.Instruction++, outcome->Proc_Beg);
			 } else if ($3 -> Value == 1 && $2 == NULL) { // If you have ID ASSIGN expression
				struct record * record_p = create_new_record();
				if (x == 0) { //Local Variable
					if ($3->Global) { //Check right hand side Global
						fprintf(output, "%d     contents b, %d := contents r%d, %d \n", GlobalTrack.Instruction++, outcome -> offset, $3->Reg_Num, $3 -> Offset);
						outcome -> Reg_Num = $3 -> Reg_Num;
					} else if ($3->isRegister) { //Check right hand side Register
						fprintf(output, "%d     contents b, %d := r%d \n", GlobalTrack.Instruction++, outcome -> offset, $3->Reg_Num);
						outcome -> Reg_Num = $3 -> Reg_Num;
					} else {
						//fprintf(output, "%d     contents b, %d := r%d\n", GlobalTrack.Instruction++, outcome->offset, outcome->Reg_Num);
						fprintf(output, "%d     contents b, %d := contents b, %d\n", GlobalTrack.Instruction++, outcome->offset, $3->Offset);
					}
				} else { //Global Variable
					fprintf(output, "%d     r%d := b\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
					while (x > 0) {
						fprintf(output, "%d     r%d := contents r%d, 2\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
						x--;
					}
					if ($3->Global) {
						fprintf(output, "%d     contents r%d, %d := contents r%d, %d \n", GlobalTrack.Instruction++, GlobalTrack.register_Num, outcome -> offset, $3->Reg_Num, $3->Offset);
						outcome -> Reg_Num = $3 -> Reg_Num;
					} else if ($3->isRegister) {
						fprintf(output, "%d     contents r%d, %d := r%d \n", GlobalTrack.Instruction++, GlobalTrack.register_Num, outcome -> offset, $3->Reg_Num);
						outcome -> Reg_Num = $3 -> Reg_Num;
					} else {
						fprintf(output, "%d     contents r%d, %d := contents b, %d \n", GlobalTrack.Instruction++, GlobalTrack.register_Num, outcome -> offset, $3->Offset);
					}
					GlobalTrack.register_Num++;
				 }
			 } else if ($2 -> record_List -> Value = 1 && $3 -> Value == 0) { //If you have read or write
				if ($2 -> next == NULL){
					if (strcmp(outcome->kind, "read_routine") == 0){
						node_t * temp = Search($2->record_List->Identifier); //Search for $1 in Global Tree
		 				strcpy($2->record_List->Parent_type, temp->parent_type->var);
						if ($2->record_List->Global) {
							fprintf(output, "%d     read_%s contents r%d, %d\n", GlobalTrack.Instruction++, $2->record_List->Parent_type, $2->record_List->Reg_Num, $2->record_List->Offset);
						} else {
							fprintf(output, "%d     read_%s contents b, %d\n", GlobalTrack.Instruction++, $2->record_List->Parent_type, $2->record_List->Offset);
						}
					}
				} else {
					while ($2 != NULL) {
						if ($2->record_List->isRegister) {
		 					fprintf(output, "%d     write r%d\n", GlobalTrack.Instruction++, $2->record_List->Reg_Num);
						} else {
		 					fprintf(output, "%d     write contents b, %d\n", GlobalTrack.Instruction++, $2->record_List->Offset);
						}
						$2 = $2 -> next;
					}
				}
			 } /*else { //Else it is an array
         if (x == 0) { //Local Variable
           if (outcome -> lower != 0)  {
             int temp = $2->record_List->check - outcome -> lower;
             fprintf(output, "%d     r%d := %d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, temp, outcome -> offset);
             fprintf(output, "%d     r%d := contents b, r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
           } else {
           fprintf(output, "%d     r%d := r%d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $2 -> record_List -> Reg_Num, outcome->offset);
           }
          if ($3->Reg_Num){
            fprintf(output, "%d     contents b, r%d := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $3->Reg_Num);
          } else {
            fprintf(output, "%d     contents b, r%d := contents b, %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $3->Value);
          }
          GlobalTrack.register_Num++;
        } else {
          fprintf(output, "%d     r%d := b\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
					while (x > 0) {
						fprintf(output, "%d     r%d := contents r%d, 2\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
						x--;
					}
          if (outcome -> lower != 0)  {
            int temp = $2->record_List->check - outcome -> lower;
            fprintf(output, "%d     r%d := %d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, temp, outcome -> offset);
            fprintf(output, "%d     r%d := contents b, r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
          } else {
          fprintf(output, "%d     r%d := r%d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $2 -> record_List -> Reg_Num, outcome->offset);
          }
         if ($3->Reg_Num){
           fprintf(output, "%d     contents b, r%d := r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $3->Reg_Num);
         } else {
           fprintf(output, "%d     contents b, r%d := contents b, %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $3->Value);
         }
         GlobalTrack.register_Num++;
        }
       }*/
			}
                        | loop_part
                        | if_statement
                        | RAISE ID ';'
			;
op_param		: '(' expression_list ')'
			{
			 $$ = $2;
			}
			| %empty
			{
			 $$ = NULL;
			}
			;
op_assign		: ASSIGN expression
			{
			 struct record * record_p = create_new_record();
			 record_p -> Reg_Num = $2 -> Reg_Num;
			 record_p -> isRegister = true;
			 record_p -> Offset = $2 -> Offset;
			 record_p -> Value = 1;
			 $$ = record_p;
			}
			| %empty
			{
			 struct record * record_p = create_new_record();
			 record_p -> Value = 0;
			 $$ = record_p;
			}
			;
expression_list         : expression ',' expression_list
			{
				$3 = insertRW($3, $1);
			 	$3 -> record_List -> Value = 1;
				$$ = $3;
			}
                        | expression
			{ //TODO What is happening? Please check...
         			 printf("KLJASKLALKL %d\n", $1 -> Value);
         			 int temp = $1 -> Value;
				 struct LL_RW * RW  = initRW($1);
			 	 RW -> record_List -> Value = 1;
			 	 RW -> record_List -> check = temp;
        			 printf("KLJASKLALKL %d\n", $1 -> Value);
         			 printf("KLJASKLALKL %d\n", temp);
				 $$ = RW;
			}
                        ;
loop_part               : loop_start loop_stmt_list ENDLOOP ';'
			{
			 fprintf(output, "%d     pc := %d\n", GlobalTrack.Instruction++, $1);
       struct patch_list * temp = ToPatch_Arr[ToPatchCounter];
       while (temp != NULL) {
            AddPatchList(temp->location, GlobalTrack.Instruction);
            temp = temp->next;
       }
       PopToPatchStack();
      }
                        ;
loop_start              : LOOP
			{
      			PushToPatchStack();
			$$ = GlobalTrack.Instruction;
			}
                        ;
loop_stmt_list          : loop_stmt
                        | loop_stmt_list loop_stmt
                        ;
loop_stmt               : statement
                        | exit_cond
                        ;
exit_cond               : EXIT ';'
			{
			  //printf("STRUCT IS AT POSITION %d\n", ToPatchCounter);
			  AddPatch(GlobalTrack.Instruction);
			  fprintf(output, "%d     pc := ?\n", GlobalTrack.Instruction++);
			}
                        | EXITWHEN condition ';'
                        {
                          fprintf(output, "%d     pc := ? if r%d\n", GlobalTrack.Instruction++, $2->Reg_Num);
                        }
                        ;
condition               : expression
				                {$$ = $1;}
                        ;
if_statement            : IF condition then sequence_of_statements else_if else ENDIF ';'
			{
			}
                        ;
else_if                 : ELSEIF condition then sequence_of_statements else_if
                        | %empty
                        ;
then                    : THEN
                        {
                          int temp = GlobalTrack.register_Num - 1;
                          fprintf(output, "%d     pc := ? if not r%d\n", GlobalTrack.Instruction++, temp);
                        }
                        ;
else                    : ELSE sequence_of_statements
                        | %empty
                        ;
expression              : relation
				{$$ = $1;}
                        | expression boolean_operation relation
				{
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 fprintf(output, "%d     r%d := ", GlobalTrack.Instruction++, record_p->Reg_Num);

				 if ($1->Global) {
					fprintf(output, "contents r%d, %d ", $1->Reg_Num, $1->Offset);
				 }else if ($1->isRegister) {
				 	fprintf(output, "r%d ", $1->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d ", $1->Offset);
				 }
				 //Print relational operation
				 fprintf(output, "%s ", $2);

				 if ($3->Global) {
					fprintf(output, "contents r%d, %d\n", $3->Reg_Num, $3->Offset);
				 } else if ($3->isRegister) {
				 	fprintf(output, "r%d \n", $3->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d\n", $3->Offset);
				 }
				 $$ = record_p;
				}
			;
relation                : simple_expression
				{$$ = $1;
				 //fprintf(output, "In the rule relation derives SimpExp, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER IS, %d\n", $1->Reg_Num);
				 //fflush(output);
				}
                        | relation relational_operation simple_expression
				{
				 //fprintf(output, "In the rule relation derives rrs, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER for relation, %d\n", $1->Reg_Num);
				 //fprintf(output, "In the rule SimpExp derives term, %d\n", $3->Value);
				 //fprintf(output, "REGISTER NUMBER for SimpExp, %d\n", $3->Reg_Num);
				 //fflush(output);
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 fprintf(output, "%d     r%d := ", GlobalTrack.Instruction++, record_p->Reg_Num);
				 if (strcmp($2, ">") == 0){
				 	if ($3->Global) {
						fprintf(output, "contents r%d, %d ", $3->Reg_Num, $3->Offset);
				 	}else if ($3->isRegister) {
				 		fprintf(output, "r%d ", $3->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d ", $3->Offset);
				 	}
				 	//Print relational operation
				 	fprintf(output, "< ");

				 	if ($1->Global) {
						fprintf(output, "contents r%d, %d\n", $1->Reg_Num, $1->Offset);
				 	} else if ($1->isRegister) {
				 		fprintf(output, "r%d \n", $1->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d\n", $1->Offset);
				 	}
				 } else if (strcmp($2,">=") == 0) {
					if ($3->Global) {
						fprintf(output, "contents r%d, %d ", $3->Reg_Num, $3->Offset);
				 	}else if ($3->isRegister) {
				 		fprintf(output, "r%d ", $3->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d ", $3->Offset);
				 	}

				 	//Print relational operation
				 	fprintf(output, "<= ");

				 	if ($1->Global) {
						fprintf(output, "contents r%d, %d\n", $1->Reg_Num, $1->Offset);
				 	} else if ($1->isRegister) {
				 		fprintf(output, "r%d \n", $1->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d\n", $1->Offset);
				 	}
				 } else {
				 	if ($1->Global) {
						fprintf(output, "contents r%d, %d ", $1->Reg_Num, $1->Offset);
					}else if ($1->isRegister) {
				 		fprintf(output, "r%d ", $1->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d ", $1->Offset);
				 	}

				 	//Print relational operation
				 	fprintf(output, "%s ", $2);

				 	if ($3->Global) {
						fprintf(output, "contents r%d, %d\n", $3->Reg_Num, $3->Offset);
				 	} else if ($3->isRegister) {
				 		fprintf(output, "r%d \n", $3->Reg_Num);
				 	} else {
						fprintf(output, "contents b, %d\n", $3->Offset);
				 	}
				}
				 	$$ = record_p;
			}
                        ;
simple_expression       : term
				{$$ = $1;
				 //fprintf(output, "In the rule SimpExp derives term, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER IS, %d\n", $1->Reg_Num);
				 //fflush(output);
				}
			| '-' term
				{
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 fprintf(output, "%d     r%d := - ", GlobalTrack.Instruction++, record_p->Reg_Num);
				 //Handle Left hand sideof operation
				 if ($2->isRegister) {
				 	fprintf(output, "r%d \n", $2->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d \n", $2->Offset);
				 }
				$$ = record_p;
				}
			| simple_expression adding_operation term
				{
				 //fprintf(output, "In the rule SimpExp derives sat, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER for SimpExp, %d\n", $1->Reg_Num);
				 //fprintf(output, "In the rule SimpExp derives sat, %d\n", $3->Value);
				 //fprintf(output, "REGISTER NUMBER for term, %d\n", $1->Reg_Num);
				 //fflush(output);
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 fprintf(output, "%d     r%d := ", GlobalTrack.Instruction++, record_p->Reg_Num);
				 //Handle Left hand sideof operation
				 if ($1->Global) {
					fprintf(output, "contents r%d, %d ", $1->Reg_Num, $1->Offset);
				 }else if ($1->isRegister) {
				 	fprintf(output, "r%d ", $1->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d ", $1->Offset);
				 }

				 //Print + or -
				 fprintf(output, "%s ", $2);

				 if ($3->Global) {
					fprintf(output, "contents r%d, %d \n", $3->Reg_Num, $3->Offset);
				 } else if ($3->isRegister) {
				 	fprintf(output, "r%d \n", $3->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d \n", $3->Offset);
				 }
				 $$ = record_p;
				}
                        ;
term                    : factor
				{$$ = $1;
				 //fprintf(output, "In the rule term derives factor, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER IS, %d\n", $1->Reg_Num);
				 //fprintf(output, "Register is %s\n", $1->isRegister ? "true" : "false");
				 //fflush(output);
				}
                        | term multiplying_operation factor
				{
				 //fprintf(output, "In the rule term derives tmf, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER for term, %d\n", $1->Reg_Num);
				 //fprintf(output, "In the rule term derives tmf, %d\n", $3->Value);
				 //fprintf(output, "REGISTER NUMBER for factor, %d\n", $3->Reg_Num);
				 //fflush(output);
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 record_p -> Global = false;
				 fprintf(output, "%d     r%d := ", GlobalTrack.Instruction++, record_p->Reg_Num);
				 //Handle Left hand sideof operation
				 if ($1->Global) {
					fprintf(output, "contents r%d, %d ", $1->Reg_Num, $1->Offset);
				 }else if ($1->isRegister) {
				 	fprintf(output, "r%d ", $1->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d ", $1->Offset);
				 }

				 //Print * or /
				 fprintf(output, "%s ", $2);

				 if ($3->Global) {
					fprintf(output, "contents r%d, %d \n", $3->Reg_Num, $3->Offset);
				 } else if ($3->isRegister) {
				 	fprintf(output, "r%d \n", $3->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d \n", $3->Offset);
				 }
				 $$ = record_p;
				}
                        ;
factor                  : primary
				{$$ = $1;
				 //fprintf(output, "In the rule Factor derives Primary, %d\n", $1->Value);
				 //fprintf(output, "REGISTER NUMBER IS, %d\n", $1->Reg_Num);
				 //fflush(output);
				}
			| primary EXP primary
				{
				 //TODO EMIT several Argument Arithmetic instructions
				$$ = $1;
				}

                        | NOT primary
				{
				 struct record * record_p = create_new_record();
				 record_p -> Reg_Num = GlobalTrack.register_Num++;
				 record_p -> isRegister = true;
				 record_p -> Global = false;
				 fprintf(output, "%d     r%d := not ", GlobalTrack.Instruction++, record_p->Reg_Num);
				 //Handle Left hand sideof operation
				 if ($2->isRegister) {
				 	fprintf(output, "r%d \n", $2->Reg_Num);
				 } else {
					fprintf(output, "contents b, %d \n", $2->Offset);
				 }
				strcpy(record_p->Identifier, $2->Identifier);
				$$ = record_p;
				}
                        ;
primary                 : NUMBER
				{//fprintf(output, "In the rule primary derives NUMBER, %d\n", $1);
				 //fflush(output);
				 struct record * record_p = create_new_record();
				 record_p->Value = $1;
				 record_p->Reg_Num = GlobalTrack.register_Num++;
				 record_p -> Global = false;
				 record_p->isRegister = true;
				 //fprintf(output, "REGISTER NUMBER IS, %d\n", record_p->Reg_Num);
				 fprintf(output, "%d     r%d := %d\n", GlobalTrack.Instruction++, record_p->Reg_Num, $1);
				 $$ = record_p;
				}
                        | ID
			{
				 struct record * record_p = create_new_record();
				 node_t * outcome = Search($1); //Search for $1 in Global Tree
				 int x = SearchPosition($1); //Check if it is local
				 strcpy(record_p->Identifier, $1);
         			 if (strcmp(outcome->kind, "literal") == 0) {
           			 	record_p -> Value = outcome -> value;
           				record_p->Reg_Num = GlobalTrack.register_Num++;
           				record_p->isRegister = true;
           				fprintf(output, "%d     r%d := %d\n", GlobalTrack.Instruction++, record_p->Reg_Num, record_p -> Value);
				 	$$ = record_p;
				  } else {
				 	if (x == 0) { //Local Variable
						record_p -> Offset = outcome -> offset;
						if (outcome -> Reg_Num > 0) {
							record_p -> Reg_Num = outcome -> Reg_Num;
				 			record_p -> isRegister = true;
						} else {
              fprintf(output, "%d     r%d := contents b, %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, outcome->offset);
              record_p->Reg_Num = GlobalTrack.register_Num++;
              record_p -> isRegister = true;
            }
				 	} else { //Global Variable
						fprintf(output, "%d     r%d := b\n", GlobalTrack.Instruction++, GlobalTrack.register_Num);
						while (x > 0) {
							fprintf(output, "%d     r%d := contents r%d, 2\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
							x--;
						}
						record_p -> Offset = outcome -> offset;
						record_p -> Reg_Num = GlobalTrack.register_Num++;
						record_p -> Global = true;
				 		record_p -> isRegister = true;
				 	}
        			 }
				 $$ = record_p;
       			}
			| '(' expression ')'
			{$$ = $2;}
			| ID '(' expression ')'
			{
      struct record * record_p = create_new_record();
      node_t * outcome = Search($1); //Search for $1 in Global Tree
      int x = SearchPosition($1); //Check if it is local
      if (outcome -> lower != 0)  {
        int temp = $3->Value - outcome -> lower;
        fprintf(output, "%d     r%d := %d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, temp, outcome -> offset);
        fprintf(output, "%d     r%d := contents b, r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
        record_p -> Offset = outcome -> offset;
        record_p -> Reg_Num = GlobalTrack.register_Num++;
        record_p -> Global = true;
        record_p -> isRegister = true;
      } else {
        fprintf(output, "%d     r%d := r%d + %d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, $3->Reg_Num, outcome->offset);
        fprintf(output, "%d     r%d := contents b, r%d\n", GlobalTrack.Instruction++, GlobalTrack.register_Num, GlobalTrack.register_Num);
        record_p -> Offset = outcome -> offset;
        record_p -> Reg_Num = GlobalTrack.register_Num++;
        record_p -> Global = true;
        record_p -> isRegister = true;
      }
      $$ = record_p;
			}
			;
boolean_operation       : AND
				{strcpy($$, "and");}
                        | OR
				{strcpy($$, "or");}
                        ;
relational_operation    : EQ
				{strcpy($$, "=");}
                        | NEQ
				{strcpy($$, "/=");}
                        | LT
				{strcpy($$, "<");}
                        | GT
				{strcpy($$, ">");}
                        | GTE
				{strcpy($$, ">=");}
                        | LTE
				{strcpy($$, "<=");}
                        ;
adding_operation        : '+'
				{strcpy($$, "+");}
                        | '-'
				{strcpy($$, "-");}
                        ;
multiplying_operation   : '*'
				{strcpy($$, "*");}
                        | '/'
				{strcpy($$, "/");}
			;
exception_part          : exception_start exceptionList
                        | %empty
                        ;
exception_start         : EXCEPTION
                        ;
exceptionList           : exceptionList exceptionHandler
                        | exceptionHandler
                        ;
exceptionHandler        : WHEN choice_sequence ARROW sequence_of_statements
                        ;
choice_sequence         : choice_sequence '|' ID
                        | ID
                        | OTHERS
                        ;


%%
int main()
{
  output = fopen("./simple.out", "w");
  OuterContext();
  yyparse();
  fclose(output);
}
